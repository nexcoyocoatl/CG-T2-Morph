Computer Graphics Assignment. 3D Geometry Morphing study with raycasting algorithm.

# Relatório de Sistema para Geração de Objetos Poliédricos baseado em <i>Morphing</i> Geométrico

## 1. Introdução
<p align="justify"> A proposta deste trabalho envolve a construção de um algoritmo – ou coleção de algoritmos – que, de forma genérica, possibilita, através de manipulação procedural de elementos de uma malha 3D – sendo estes vértices, arestas e faces – a “transformação” por animação para outro modelo, tendo exatamente as mesmas características quanto a sua estrutura geométrica, incluindo o exato número destes elementos.</p>
<p align="justify">O desafio está na diferença inerente entre a complexidade de dois modelos 3D, não só em relação aos seus elementos geométricos, mas em como se conectam e como são formados. Por exemplo, uma malha pode ser construída apenas com triângulos pela sua simplicidade, mas geralmente são utilizados quadriláteros pela facilidade de realizar operações envolvendo múltiplas faces em softwares de modelagem 3D, tanto artísticos (<i>Blender</i>) quanto técnicos (<i>AutoCAD</i>), mas em certos casos, ainda, pode se encontrar uma mistura dos dois, bem como alguns <i>ngons</i> (mais de quatro lados) como facilitadores de conexões topólogicas. 	Isto é apenas um – mas talvez o mais importante – fator que a dificulta implementação de um algoritmo procedural genérico.</p>
<p align="justify">Para esta solução, foram examinadas diversas possíveis soluções, algumas implementadas de forma incompleta, mas a escolhida para esta aplicação em específico foi a técnica de <i>raycast</i> com a intenção de estudar além dos conteúdos de aula e como um desafio. Esa implementação, porém, no momento encontra-se incompleta, incluindo apenas uma possível iteração inicial de um <i>morphing</i> final que envolveria diversas outras etapas – cada uma com um algoritmo diferente – que acabariam por formar <i>keyframes</i> de uma animação ideal de um modelo 3D para o outro preservando suas características durante o processo.</p>

## 2. Modelagem da Solução
<p align="justify">Para iniciar o trabalho, no intuito de exercitar uma linguagem de programação mais utilizada na área, e para compreender melhor o código base em <i>Python</i> disponibilizado, fez-se a conversão para C++. Isto provocou alguns problemas durante parte do desenvolvimento do trabalho em que foi necessário lidar com a falta de experiência em linguagens com certos conceitos de baixo nível. Não foram um impedimento, porém; pelo contrário, enriqueceram o conhecimento do aluno.</p>
<p align="justify">Após a refatoração para C++, e em um primeiro momento da modelagem, a ideia ingênua de <i>morphing</i> entre duas malhas 3D parecia simples. No entanto, tentativas iniciais de abstração do problema apresentaram obstáculos e soluções que aparentavam serem simples foram sendo abandonadas devido a ineficácia ou complexidade.</p>
<p align="justify">Uma delas foi a ideia de subdividir as malhas em quadriláteros para que pudessem ficar com o mesmo número de faces. Para isto foi criada uma função genérica que obtem o centróide a partir da média de seus vértices, e então, adicionando novos vértices na divisão central de cada aresta, pode-se juntá-los para também formar novas faces.</p>

<img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/subdivision1.png" alt="subdivision1" width="500"/><img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/subdivision2.png" alt="subdivision2" width="286"/>  
Primeira ideia para subdivisão de faces.&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Malha subdividida em 4 iterações

<p align="justify">A dificuldade se apresenta no fato de que que, apesar de genérico, podendo ser aplicado até para triângulos e <i>ngons</i>, seria necessário criar uma outra função que faria uma relação entre o número de faces dos dois modelos e tentaria subdividir para que chegassem a um número próximo um do outro. Isso complexificaria a malha em certas partes, porém, dificultando o <i>morph</i> pela possibilidade da relação de muitos para poucos vértices em coordenadas semelhantes; levando em conta que várias faces dividem vértices também poderia fazer com que faces que eram adjacentes ficassem distantes na transformação, não chegando a forma correta do segundo objeto durante a animação.</p>
<p align="justify">A fim de simplificar o processo e deixar as faces uniformes em seu formato mais básico, optou-se por utilizar uma função que triangula as faces com quatro vértices ou mais, e ignora todas aquelas que já são triângulos. Assim, foi criada uma função que tem como base o método iterativo de “orelhas” para triangular qualquer tipo de face. Para visualizar o algoritmo, foi utilizado o software de modelagem 3D <i>Blender</i> com o modificador <i>triangulate</i> em diversas faces separadas criadas para tal propósito.</p>

<img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/triangulate1.png" alt="triangulate1" width="400"/><img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/triangulate2.png" alt="triangulate2" width="400"/>  
Hexadecágono triangulado no Blender

<p align="justify">Após estas primeiros esboços de tentativas ficou claro que o resultado do <i>morphing</i>, mesmo quando realizado de forma correta na relação de um objeto para outro, não consideraria o espaço tridimensional, apenas o que estaria na estrutura dos dados, como a numeração dos elementos de <i>arrays</i> de vértices por índice, por exemplo. Foi assim que, conversando com a professora e descobrindo a possibilidade de uso de <i>raycast</i>, o interesse pela técnica foi motivador para um novo desafio. A proposta de solução do aluno partiu, então, da criação de uma primeira etapa de <i>morphing</i> em que vértices de um primeiro objeto procuram faces de um outro objeto com um raio seguindo perpendicular às suas normais para então “colarem-se” nesta face e emulando a nova forma. Embora não implementadas as etapas seguintes, a intenção era utilizar estes vértices próximos aos da malha a ser transformada para subdividí-los adequadamente; possivelmente com a projeção planar de todos vértices existentes entre as faces dos dois modelos para encontrar o número exato de subdivisões.</p>
<p align="justify">A utilização do primeiro método de <i>raycasting</i> foi trabalhosa devido a inexperiência com a técnica, mas com a utilização de álgebra linear de planos e retas é possível encontrar pontos no espaço “lançados” através de um “raio” com um ponto inicial e um vetor direcional, para então encontrar um fim na intersecção desta reta com uma face, que pode ser abstraída para um plano infinito. Faz-se então, uma combinação algébrica da equação da reta (raio) por um plano (face, neste caso simplificada a apenas triângulos) para encontrar um possível ponto de intersecção entre os dois. Neste trabalho, este raio se apresenta com o ponto inicial na origem do SRU (Sistema de Referência do Universo), com direção da normal de um vértice para encontrar uma possível intersecção com um plano.</p>
<p align="justify">Por um momento, não foi avaliado o plano como finito em sua face triangular, e isso levou a erros de pontos finais de raios perdidos no espaço. O cálculo barimétrico do triângulo foi utilizado para encontrar seu possível centro após a intersecção do plano e, portanto, se o ponto realmente está dentro do triângulo, e não só do plano infinito. Estes cálculos são realizados em O(N2) por fazerem a checagem de cada vértice por cada face, e para tentar suavizar o processamento, foi utilizada uma aproximação de raiz quadrada (utilizada no cálculo barimétrico) com um inverso de raiz quadrada utilizando a curva do log(1 + x) ≈ x que acaba por ser semelhante a de raiz quadrada inversa. Devido ao algoritmo ser muito antigo, porém, pouca diferença – se alguma – faz na velocidade de processamento do programa, mas a busca por novas alternativas de eficiência, conhecimento e entendimento do histórico da computação gráfica são de interesse do aluno, e a implentação – por mais simples que seja – se fez útil nesse sentido.</p>

<img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/raycast1.png" alt="raycast1" width="268"/><img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/raycast2.png" alt="raycast2" width="330"/><img src="https://github.com/nexcoyocoatl/CG-T2-Morph/blob/main/readme/raycast3.png" alt="raycast3" width="303"/>  
Teste do <i>raycast</i> com desenho dos raios. Na terceira imagem, vértices se encontram com as faces da segunda malha.

<p align="justify">Por fim, o último obstáculo se encontra na animação. Ainda que o algoritmo de <i>morphing</i> seja implementado apenas em parte, foi necessário demonstrar esta primeira etapa através de movimento. No caso deste código, foram criadas duas cópias de estrutura de dados do objeto a ser realizado o <i>morph</i>. Uma delas com o primeiro <i>keyframe</i>, a segunda com os vértices manipulados pelo <i>raycast</i>, e o original para ser utilizado na interpolação entre os <i>keyframes</i>. Primeiro é feito o cálculo da distância da posição inicial pela final, vértice por vértice; estes divididos por um número arbitrário de <i>frames</i> para que se possa iterar <i>frame</i> por <i>frame</i> por esse incremento. Houve uma tentativa de usar tempo delta, mas como a lógica desta animação se baseia em número máximo de <i>frames</i>, o programa acabava por animar muito mais rápido do que o esperado dependendo do processamento, e por isso se optou pela remoção deste.</p>

## 3. Conclusões
<p align="justify">Apesar de incompleto, o algoritmo se propõe à realização de uma primeira etapa de <i>morphing</i> que considera os modelos em seu espaço 3D, e justamente por isso possibilita uma transformação suave. Não foi possível ir além neste momento, mas ideias de próximas etapas envolvem geometrias intermediárias que poderiam ser formadas pela esferificação do segundo modelo como uma “visão explodida” dos vértices em um raio de tamanho arbitrário para evitar possíveis superfícies côncavas na topologia e um <i>raycast</i> planar através da projeção 2D dos vértices do resultado do <i>raycast</i> utilizado nesse trabalho nas faces desta esfera. A animação inversa da esferificação completaria o <i>morphing</i>.</p>
<p align="justify">Esta atividade teve grande valor não só como uma forma de estudo mais aprofundado de parte da computação gráfica, mas também como um desafio. Após diversas tentativas de encontrar um resultado satisfatório, e dentre todos os erros, foi possível entender melhor diversos conceitos vistos em aula, bem como buscar novos conhecimentos. Ainda que não tenha sido adequado de acordo com o enunciado, o autor deste relatório espera ansioso por mais desafios como este.</p>
